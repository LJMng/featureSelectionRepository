package featureSelection.tester.statistics.info;

import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

import featureSelection.basic.lang.dataStructure.IntArrayKey;
import featureSelection.basic.procedure.ProcedureContainer;
import featureSelection.basic.procedure.timer.TimeSum;
import featureSelection.basic.support.calculation.FeatureImportance;
import featureSelection.tester.procedure.param.ParameterConstants;
import featureSelection.tester.statistics.StatisticsConstants;
import lombok.Getter;
import lombok.Setter;

/**
 * A entity for executions info. storage with following fields:
 * <ul>
 * 	<li><strong>randomSeeds</strong>: {@link int[]}
 * 		<p>Random seeds of executions.
 * 	</li>
 * 	<li><strong>containerIDs</strong>: {@link StringBuilder}
 * 		<p>Container IDs of executions. Can be reset by user({@link #setContainerIDs(String)}.
 * 	</li>
 * 	<li><strong>componentTagSumTimeMap</strong>: {@link Map<String, Long>}
 * 		<p>Component sum times group by tag. (Time unit: nano)
 * 	</li>
 * 	<li><strong>containerReports</strong>: {@link ProcedureContainer[]}
 * 		<p>{@link ProcedureContainer}s used in executions in order.
 * 	</li>
 * 	<li><strong>redCollector</strong>: {@link Map}
 * 		<p>A map with previous reduct as key and maps as values. The nested map's keys are
 * 			new reducts that found in execution(previous reduct attributes excluded) and
 * 			values are {@link Reduct} {@link Collection}s as reduct info.
 * 	</li>
 * 	<li><strong>calculations</strong>: {@link FeatureImportance[]}
 * 		<p>{@link FeatureImportance} used in executions.
 * 	</li>
 *	 <li><strong>exitInfos</strong>: {@link ExitInfo[]}
 * 		<p>{@link ExitInfo} of executions.
 * 	</li>
 * 	<li><strong>extraStorage</strong>: {@link Map<String, Object>}
 * 		<p>Extra space for some extra storage.
 * 	</li>
 * </ul>
 * 
 * @author Benjamin_L
 *
 * @param <Reduct>
 * 		Type of Reduct info.
 */
@Getter
public class ExecutionInfoStorage<Reduct> {
	private int[] randomSeeds;
	private StringBuilder containerIDs;
	@Setter private Map<String, Long> componentTagSumTimeMap;
	private ProcedureContainer<?>[] containerReports;
	// <previous reduct key, <new reduct key(previous reduct attributes excluded), reduct info.s>>
	private Map<IntArrayKey, Map<IntArrayKey, Collection<Reduct>>> redCollector;
	private FeatureImportance<?>[] calculations;
	
	private ExitInfo[] exitInfos;
	
	private Map<String, Object> extraStorage;
	
	public ExecutionInfoStorage(int times, int previousReduct) {
		this(times, previousReduct, false);
	}
	public ExecutionInfoStorage(int times, int previousReduct, boolean withExtraStorage) {
		randomSeeds = new int[times];
		containerIDs = new StringBuilder();
		componentTagSumTimeMap = new HashMap<>(previousReduct);
		containerReports = new ProcedureContainer<?>[times];
		redCollector = new HashMap<>();
		calculations = new FeatureImportance<?>[times];
		
		exitInfos = new ExitInfo[times];
		
		extraStorage = withExtraStorage? null: new HashMap<>();
	}
	
	public int getTimes() {
		return randomSeeds.length;
	}
	
	/**
	 * Store execution result of time <code>t</code>.
	 * <p>
	 * When storing, the following operation will execute:
	 * <ul>
	 * 	<li>
	 * 		{@link #addContainerID(int, ProcedureContainer)}
	 * 		<p>Update container ids.
	 * 	</li>
	 * 	<li>
	 * 		{@link #setRandomSeedOf(int, int)}
	 * 		<p>Save the random seed.
	 * 	</li>
	 * 	<li>
	 * 		{@link #setContainerReportOf(int, ProcedureContainer)}
	 * 		<p>Save report of {@link ProcedureContainer}.
	 * 	</li>
	 * 	<li>
	 * 		{@link #collectReducts(int[], Map)}
	 * 		<p>Collect new reducts bases on previous reduct.
	 * 	</li>
	 * 	<li>
	 * 		{@link #addCalculation(int, ProcedureContainer)}
	 * 	</li>
	 * 	<li>
	 * 		{@link #setExitInfoOf(int, Map)}
	 * 	</li>
	 * </ul>
	 * 
	 * @param t
	 * 		The <code>t</code>th time execution. (Starts from 0)
	 * @param randomSeed
	 * 		The random seed used in execution.
	 * @param procedure
	 * 		The {@link ProcedureContainer} for execution.
	 * @param redMap
	 * 		The reduct {@link Map} generated by the execution of {@link ProcedureContainer},
	 * 		with full final sorted reduct in {@link IntArrayKey} as key and codings
	 * 		{@link Collection} in {@link Reduct}.
	 * @param statistics
	 * 		Statistics {@link Map} of {@link ProcedureContainer}.
	 * @param previousReduct
	 * 		Previous reduct.
	 */
	public void store(
			int t, int randomSeed, ProcedureContainer<?> procedure,
			Map<IntArrayKey, Collection<Reduct>> redMap, Map<String, Object> statistics,
			int[] previousReduct
	) {
		addContainerID(t, procedure);
		setRandomSeedOf(t, randomSeed);
		setContainerReportOf(t, procedure);
		collectReducts(previousReduct, redMap);
		updateComponentTagSumTimeMap(procedure);
		addCalculation(t, procedure);
		setExitInfoOf(t, statistics);
	}
	
	/**
	 * Append container id using {@link ProcedureContainer#id()} and "+".
	 * 
	 * @param t
	 * 		The <code>t</code>th time execution. (Starts from 0)
	 * @param procedure
	 * 		The {@link ProcedureContainer} for execution.
	 */
	protected void addContainerID(int t, ProcedureContainer<?> procedure) {
		containerIDs.append(procedure.id());	
		if (t!=randomSeeds.length-1)	containerIDs.append("+");
	}
	
	/**
	 * Save the random seed value.
	 * 
	 * @param t
	 * 		The <code>t</code>th time execution. (Starts from 0)
	 * @param randomSeed
	 * 		The random seed value.
	 */
	protected void setRandomSeedOf(int t, int randomSeed) {
		randomSeeds[t] = randomSeed;
	}
	
	/**
	 * Save report of {@link ProcedureContainer}.
	 * 
	 * @param t
	 * 		The <code>t</code>th time execution. (Starts from 0)
	 * @param containerReport
	 * 		The {@link ProcedureContainer} for execution.
	 */
	protected void setContainerReportOf(int t, ProcedureContainer<?> containerReport) {
		this.containerReports[t] = containerReport;
	}
	
	/**
	 * Collect new reduct generated by execution.
	 * 
	 * @param previousReduct
	 * 		The previous reduct that the execution bases on.
	 * @param redMap
	 * 		The reduct {@link Map} generated by the execution of {@link ProcedureContainer},
	 * 		with full final sorted reduct in {@link IntArrayKey} as key and codings
	 * 		{@link Collection} in {@link Reduct}.
	 */
	public void collectReducts(int[] previousReduct, Map<IntArrayKey, Collection<Reduct>> redMap) {
		if (redMap!=null) {
			// locate by previous reduct @ redCollector
			IntArrayKey previousReductKey = new IntArrayKey(previousReduct);	
			Map<IntArrayKey, Collection<Reduct>> previousSubsequences = redCollector.get(previousReductKey);
			if (previousSubsequences==null) {
				redCollector.put(
						previousReductKey,
						previousSubsequences = new HashMap<>(redMap.size())
				);
			}
			// update new reduct @ previousSubsequences
			Collection<Reduct> newReductCollection;
			for (Map.Entry<IntArrayKey, Collection<Reduct>> newReductInfos: redMap.entrySet()) {
				// locate by new reduct @ previousSubsequences
				newReductCollection = previousSubsequences.get(newReductInfos.getKey());
				if (newReductCollection==null) {
					previousSubsequences.put(
							newReductInfos.getKey(),
							newReductCollection = new LinkedList<>()
					);
				}
				newReductCollection.addAll(newReductInfos.getValue());
			}
		}
	}

	/**
	 * Update {@link #componentTagSumTimeMap} by adding time in the given
	 * {@link ProcedureContainer} if it is instance of {@link TimeSum}.
	 * 
	 * @see TimeSum
	 * 
	 * @param procedure
	 * 		The executed {@link ProcedureContainer} instance.
	 */
	protected void updateComponentTagSumTimeMap(ProcedureContainer<?> procedure) {
		if (procedure instanceof TimeSum) {
			Map<String, Long> timeDetailMap = ((TimeSum) procedure).getTimeDetailByTags();
			for (Map.Entry<String, Long> timeDetail: timeDetailMap.entrySet()) {
				Long timeValue = componentTagSumTimeMap.get(timeDetail.getKey());
				if (timeValue==null)	timeValue = 0L;
				componentTagSumTimeMap.put(timeDetail.getKey(), timeDetail.getValue()+timeValue);
			}
		}
	}
	
	/**
	 * Save a calculation instance.
	 * 
	 * @see ParameterConstants#PARAMETER_SIG_CALCULATION_INSTANCE
	 * 
	 * @param t
	 * 		The <code>t</code>th time execution. (Starts from 0)
	 * @param procedure
	 * 		The executed {@link ProcedureContainer}.
	 */
	protected void addCalculation(int t, ProcedureContainer<?> procedure) {
		calculations[t] = procedure.getParameters()
									.get(ParameterConstants.PARAMETER_SIG_CALCULATION_INSTANCE);
	}
	
	/**
	 * Save the exit informations.
	 * 
	 * @see ExitInfo
	 * @see StatisticsConstants.OptimizationInfo.Exit#STATISTIC_OPTIMIZATION_EXIT_ITERATION
	 * @see StatisticsConstants.OptimizationInfo.Exit#STATISTIC_OPTIMIZATION_EXIT_CONVERGENCE
	 * @see StatisticsConstants.OptimizationInfo.Exit#STATISTIC_OPTIMIZATION_EXIT_FITNESS
	 * 
	 * @param t
	 * 		The <code>t</code>th time execution. (Starts from 0)
	 * @param statistics
	 * 		Statistics {@link Map} of {@link ProcedureContainer}.
	 */
	protected void setExitInfoOf(int t, Map<String, Object> statistics) {
		// iteration
		Integer iteration =
				(Integer) statistics.get(
						StatisticsConstants.OptimizationInfo.Exit.STATISTIC_OPTIMIZATION_EXIT_ITERATION
				);
		if (iteration==null)	iteration = 0;
		// convergence
		Integer convergence =
				(Integer) statistics.get(
						StatisticsConstants.OptimizationInfo.Exit.STATISTIC_OPTIMIZATION_EXIT_CONVERGENCE
				);
		if (convergence==null)	convergence = 0;
		// fitness
		Number fitness =
				(Number) statistics.get(
						StatisticsConstants.OptimizationInfo.Exit.STATISTIC_OPTIMIZATION_EXIT_FITNESS
				);
		if (fitness==null)		fitness = 0;
		// exit reason
		String exitReason =
				(String) statistics.get(
						StatisticsConstants.OptimizationInfo.Exit.STATISTIC_OPTIMIZATION_EXIT_REASON
				);
		// Set ExitInfo.
		exitInfos[t] =
				new ExitInfo(
						iteration,
						convergence,
						fitness instanceof Integer? fitness.intValue(): fitness.doubleValue(),
						exitReason
				);
	}
	
	/**
	 * Store extra value associated with the given key.
	 * 
	 * @param key
	 * 		 key with which the specified value is to be associated
	 * @param value
	 * 		value to be associated with the specified key
	 */
	public void extraStore(String key, Object value) {
		extraStorage.put(key, value);
	}
	
	/**
	 * Get stored extra value by key.
	 * 
	 * @param key
	 * 		 key with which the specified value is to be associated
	 * @return the value./null if no such key.
	 */
	@SuppressWarnings("unchecked")
	public <T> T getFromExtraStorage(String key) {
		return (T) extraStorage.get(key);
	}
	
	public void setContainerIDs(String containerIDs) {
		this.containerIDs = new StringBuilder(containerIDs);
	}
	
 	public String containerIDs() { return containerIDs.toString(); }
}